<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mule on On Code &amp; Design</title>
    <link>https://claudemamo.github.io/tags/mule/</link>
    <description>Recent content in Mule on On Code &amp; Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 May 2015 02:09:00 +0000</lastBuildDate>
    <atom:link href="https://claudemamo.github.io/tags/mule/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Primer to AS2</title>
      <link>https://claudemamo.github.io/2015/05/15/a-primer-to-as2/</link>
      <pubDate>Fri, 15 May 2015 02:09:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2015/05/15/a-primer-to-as2/</guid>
      <description>&lt;p&gt;Check out my&lt;a href=&#34;http://www.modusbox.com/2015/04/a-primer-to-as2/&#34; target=&#34;_blank&#34;&gt; latest guest post&lt;/a&gt;&amp;nbsp;about AS2 on ModusBox&amp;rsquo;s blog.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scaling up Mule with Async Request Handling/Continuations</title>
      <link>https://claudemamo.github.io/2014/01/07/scaling-up-mule-with-async-request-handling/continuations/</link>
      <pubDate>Tue, 07 Jan 2014 14:01:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2014/01/07/scaling-up-mule-with-async-request-handling/continuations/</guid>
      <description>&lt;p&gt;Non-blocking I/O servers such as Node.js are appealing because, when compared to blocking I/O servers, they utilise less threads to perform the same tasks under the same load. Less threads mean more efficient use of resources (e.g., smaller memory footprint) and better performance (e.g., reduced no. of context switches between threads). Let&amp;rsquo;s take a stab at having non-blocking I/O behaviour in Mule. Consider the following Mule 3.4 application calling an HTTP service:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=mule-config(1).xml&#34;&gt;&lt;/script&gt;Wrapping the&amp;nbsp;&lt;i&gt;async&lt;/i&gt;&amp;nbsp;processor around&amp;nbsp;&lt;i&gt;http:outbound-endpoint&lt;/i&gt;&amp;nbsp;prevents the receiver thread from blocking on the outgoing HTTP call. But this &lt;b&gt;kind&lt;/b&gt; of asynchronous behaviour causes the service&amp;rsquo;s reply to be ignored: certainly not what we want for the common case. Moreover, the&amp;nbsp;&lt;i&gt;async&lt;/i&gt;&amp;nbsp;processor borrows a thread from some thread pool to carry out the blocking HTTP call, preventing the borrowed thread from doing any useful work while being blocked.&lt;br /&gt;&lt;br /&gt;The aforementioned problems can generally be solved by replacing the blocking I/O library with a non-blocking version and&amp;nbsp;&lt;b&gt;&lt;a href=&#34;http://wiki.eclipse.org/Jetty/Feature/Continuations&#34; target=&#34;_blank&#34;&gt;Asynchronous Request Handling&lt;/a&gt;&lt;/b&gt;&amp;nbsp;(a.k.a continuations). Async request handling is a threading model where a thread serving a client request can be suspended and returned to its respective thread pool; free to serve other client requests. Typically the thread would be suspended after sending out a request to a remote service or kicking off a long-running computation. Although the suspended thread has forgotten about the client, the server has not. It knows the client is still waiting for a reply. For this reason, a thread can pick up where the suspended tread has left off and deliver the reply back to the client. Normally this would happen in the context of a callback.&lt;br /&gt;&lt;br /&gt;Awesome! Let&amp;rsquo;s implement this in every place where blocking I/O is present. Not so fast. First, a library supporting a non-blocking alternative to what you already have in your solution must be available. Second, to my knowledge, the only Mule transport that provides async request handling&amp;nbsp;is &lt;a href=&#34;http://www.mulesoft.org/documentation/display/current/Jetty+Transport+Reference&#34; target=&#34;_blank&#34;&gt;Jetty&lt;/a&gt;. So for this to work, the Jetty inbound-endpoint&amp;nbsp;processor must be used as the message source:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=mule-config(2).xml&#34;&gt;&lt;/script&gt;Furthermore, as shown above,&amp;nbsp;async&amp;nbsp;request handling&amp;nbsp;must be turned on by setting &lt;i&gt;useContinuations&lt;/i&gt; to true on the&amp;nbsp;Jetty connector.&lt;br /&gt;&lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;Calling an HTTP service is a fine example where we can put async&amp;nbsp;request handling to good use. The initial step is to find an HTTP client library implementing a non-blocking API [1]. I&amp;rsquo;ll opt for &lt;a href=&#34;http://hc.apache.org/httpcomponents-asyncclient-4.0.x/&#34; target=&#34;_blank&#34;&gt;Apache&amp;nbsp;HttpAsyncClient&lt;/a&gt;.&lt;/div&gt;&lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;The next step is to develop a message processor that (1) uses HttpAsyncClient to call a service, (2) registers a callback to resume processing of the client request on receiving the HTTP service reply, and (3) immediately returns the thread to its thread pool upon sending asynchronously the HTTP request. Such a processor will require special abilities so I&amp;rsquo;ll extend my processor from&amp;nbsp;&lt;i&gt;&lt;a href=&#34;http://www.mulesoft.org/docs/site/current3/apidocs/org/mule/processor/AbstractInterceptingMessageProcessor.html&#34; target=&#34;_blank&#34;&gt;AbstractInterceptingMessageProcessor&lt;/a&gt;&lt;/i&gt;:&lt;/div&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=AhcProcessor(1).java&#34;&gt;&lt;/script&gt;By inheriting from &lt;i&gt;AbstractInterceptingMessageProcessor&lt;/i&gt;, I can invoke the next processor in the flow from my callback. Speaking of callbacks, here is the snippet concerning the HTTP client:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=AhcProcessor(2).java&#34;&gt;&lt;/script&gt;Lines 10-13 initialise the HTTP client and set the server address to wherever we&amp;rsquo;re going to send the request to. Line 15 sends asynchronously the request, and registers the callback that will handle the reply. Other than the usual stuff of reading from the response stream (lines 19-22), observe that on line 23 the subsequent flow processor in invoked on a&amp;nbsp;&lt;b&gt;different&lt;/b&gt;&amp;nbsp;thread. Line 24 tells Jetty that the flow&amp;rsquo;s output message is to be used as the reply for the end-user.&lt;br /&gt;&lt;br /&gt;One additional item in the list is left: freeing the thread after invoking asynchronously the HTTP client&amp;rsquo;s &lt;i&gt;execute(&amp;hellip;)&lt;/i&gt; method. Returning &lt;i&gt;null&lt;/i&gt; from the &lt;i&gt;process(&amp;hellip;)&lt;/i&gt; method will do the job (line 40):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=AhcProcessor(3).java&#34;&gt;&lt;/script&gt;Finally, we can hook up everything together:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/8289429.js?file=mule-config(3).xml&#34;&gt;&lt;/script&gt;The &lt;a href=&#34;https://github.com/claudemamo/asynchronous-request-handling&#34; target=&#34;_blank&#34;&gt;complete example&lt;/a&gt; is found on GitHub.&lt;br /&gt;&lt;br /&gt;Hopefully async request handling will someday be &lt;a href=&#34;https://www.mulesoft.org/jira/browse/MULE-7214&#34; target=&#34;_blank&#34;&gt;part of Mule&amp;rsquo;s&amp;nbsp;default behaviour&lt;/a&gt;. Imagine how useful it would be to call almost any service (e.g., HTTP, JMS, VM) synchronously knowing fully well that behind the scenes Mule is taking care of making every remote call non-blocking.&lt;br /&gt;&lt;br /&gt;&lt;span style=&#34;font-family: Times, Times New Roman, serif; font-size: small;&#34;&gt;&lt;span class=&#34;num&#34;&gt;1:&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;text-align: justify;&#34;&gt;A client library implementation should be based on the &lt;a href=&#34;http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&#34; target=&#34;_blank&#34;&gt;Reactor pattern&lt;/a&gt; otherwise we would be going back to the original problem of many blocking threads.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bridging Mule and MSMQ with ZeroMQ</title>
      <link>https://claudemamo.github.io/2013/08/27/bridging-mule-and-msmq-with-zeromq/</link>
      <pubDate>Tue, 27 Aug 2013 17:36:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2013/08/27/bridging-mule-and-msmq-with-zeromq/</guid>
      <description>&lt;p&gt;Hearing the words Mule and Microsoft&amp;rsquo;s MSMQ in the same sentence sends a shiver down my spine. I remember once, Mule guru &lt;a href=&#34;http://blogs.mulesoft.org/author/john-demic/&#34; target=&#34;_blank&#34;&gt;John D&amp;rsquo;Emic&lt;/a&gt; and me had spent a considerable amount of time and patience getting Mule and MSMQ to talk to each other through DCOM. The major factor that contributed to this unpleasant experience was our ignorance of the numerous security measures imposed by Windows to restrict DCOM access. The morale of this story is unless you have a veteran Windows administrator at your disposal, avoid the DCOM route.&lt;br /&gt;&lt;br /&gt;So which choices do we have other than DCOM? JNI sounds promising but you are then sacrificing Mule&amp;rsquo;s platform independence. Here&amp;rsquo;s an idea: introduce a &lt;a href=&#34;http://www.eaipatterns.com/MessagingBridge.html&#34; target=&#34;_blank&#34;&gt;messaging bridge&lt;/a&gt; between Mule and MSMQ. The bridge can be implemented in any language that facilitates interaction with MSMQ. C# is an attractive option.&lt;br /&gt;&lt;br /&gt;We still have to consider which middleware to use for exchanging messages between the bridge and Mule. There are many alternatives and among them is &lt;a href=&#34;http://zeromq.org/&#34; target=&#34;_blank&#34;&gt;ZeroMQ&lt;/a&gt;. I think ZeroMQ is a good candidate for several reasons:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;It supports asynchronous communication&lt;/li&gt;&lt;li&gt;You&amp;rsquo;re not adding another component to your architecture&lt;/li&gt;&lt;li&gt;It&amp;rsquo;s well documented in addition to having a low learning curve&lt;/li&gt;&lt;li&gt;A ZeroMQ&amp;nbsp;&lt;a href=&#34;https://github.com/claudemamo/mule-transport-zeromq&#34; target=&#34;_blank&#34;&gt;transport&lt;/a&gt; [1] and &lt;a href=&#34;https://github.com/zeromq/clrzmq&#34; target=&#34;_blank&#34;&gt;binding&lt;/a&gt;&amp;nbsp;are available for Mule and C# respectively&lt;/li&gt;&lt;li&gt;It will more than likely satisfy your message throughput requirements&lt;/li&gt;&lt;/ul&gt;In as little as 15 minutes I developed a simple bridge in C#:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6345631.js?file=bridge.cs&#34;&gt;&lt;/script&gt; The above code should be self-explanatory but I&amp;rsquo;ve put comments for your convenience.&lt;br /&gt;&lt;br /&gt;Here&amp;rsquo;s the Mule 3 app dispatching messages to the bridge:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6345631.js?file=mule-config.xml&#34;&gt;&lt;/script&gt;On receiving an HTTP request, Mule leverages the ZeroMQ transport to send asynchronously the request&amp;rsquo;s payload to the bridge.&lt;br /&gt;&lt;br /&gt;In all likelihood, the illustrated bridge code for Mule-MSMQ interoperability won&amp;rsquo;t serve all your needs. I can think about a dozen features that a developer would want such as destination queues resolved at run-time, an agreed format for message content, and etc. But hey, at least it&amp;rsquo;s a start :-)&lt;br /&gt;&lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;span style=&#34;font-family: Times, Times New Roman, serif; font-size: small;&#34;&gt;&lt;span class=&#34;num&#34;&gt;1:&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Times, Times New Roman, serif;&#34;&gt;I&amp;rsquo;ve recently replaced the transport&amp;rsquo;s ZeroMQ C++ library with a &lt;a href=&#34;https://github.com/zeromq/jeromq&#34; target=&#34;_blank&#34;&gt;pure Java implementation&lt;/a&gt; of ZeroMQ.&lt;/span&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How To Publish a WADL with Mule&#39;s REST Router Module </title>
      <link>https://claudemamo.github.io/2013/03/25/how-to-publish-a-wadl-with-mules-rest-router-module/</link>
      <pubDate>Mon, 25 Mar 2013 15:37:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2013/03/25/how-to-publish-a-wadl-with-mules-rest-router-module/</guid>
      <description>&lt;p&gt;It seems to me that Mule&amp;rsquo;s &lt;a href=&#34;http://www.mulesoft.org/extensions/rest-module&#34; target=&#34;_blank&#34;&gt;REST Router module&lt;/a&gt;, which I&amp;rsquo;ve previously &lt;a href=&#34;http://ricston.com/blog/?p=2607&#34; target=&#34;_blank&#34;&gt;blogged&lt;/a&gt; about, is gaining popularity as a viable alternative to the Jersey module. Yet, the REST Router has a serious limitation in that it&amp;rsquo;s unable to generate a &lt;a href=&#34;http://www.w3.org/Submission/wadl/&#34; target=&#34;_blank&#34;&gt;WADL&lt;/a&gt;: the REST equivalent of a WSDL. Recently, I had to overcome this limitation owing to a customer requirement for producing client code from the WADL.&lt;br /&gt;&lt;br /&gt;Consider the Mule config below:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/5215459.js?file=mule-config-1.xml&#34;&gt;&lt;/script&gt;The REST Router processes HTTP requests that have a URL path matching the &lt;i&gt;templateURI&lt;/i&gt; pattern attribute. Non-matching requests are ignored by the router and passed on to the subsequent message processor which in this case is a static component. Each nested block in the router corresponds to an HTTP method. A GET request is processed by the &lt;i&gt;rest-router:get&lt;/i&gt; element, a PUT request is processed by the &lt;i&gt;rest-router:put&lt;/i&gt; element, and so on.&lt;br /&gt;&lt;br /&gt;WADL generation isn&amp;rsquo;t a feature supported by the REST Router. If I was using the Jersey module in this example, I&amp;rsquo;d get the service WADL on hitting the URL &lt;i&gt;&lt;a href=&#34;http://localhost:8081/application.wadl&#34;&gt;http://localhost:8081/application.wadl&lt;/a&gt;&lt;/i&gt;. Although I&amp;rsquo;d like to avoid using Jersey for various reasons, I could leverage the library&amp;rsquo;s WADL generation feature:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/5215459.js?file=mule-config-2.xml&#34;&gt;&lt;/script&gt;The above modified Mule config routes WADL requests to Jersey and all other requests to the REST Router. Upon receiving a WADL request, Jersey returns the WADL derived from the JAX-RS annotated&amp;nbsp;&lt;i&gt;org.ossandme.CommentResource&lt;/i&gt;.&amp;nbsp;&lt;i&gt;CommentResource&lt;/i&gt; describes in Java the same RESTful interface described by the REST Router. Since all service logic is performed by the REST Router, I implement the resource as a Java interface instead of a class:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/5215459.js?file=CommentResource.java&#34;&gt;&lt;/script&gt;This example is a Maven project hosted on &lt;a href=&#34;https://github.com/claudemamo/mule-rest-wadl&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;. To run it, (1) open your console and enter from the project root&amp;rsquo;s directory:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/5215459.js?file=build.sh&#34;&gt;&lt;/script&gt;(2) Then deploy the package on Mule 3.3.x standalone runtime. Accessing the URL&amp;nbsp;&lt;i&gt;&lt;a href=&#34;http://localhost:8081/application.wadl&#34;&gt;http://localhost:8081/application.wadl&lt;/a&gt;&lt;/i&gt;&amp;nbsp;will give you the following:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/5215459.js?file=application.wadl&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mule ZeroMQ Transport: Lightweight RPC with ØMQ and Protocol Buffers</title>
      <link>https://claudemamo.github.io/2012/11/06/mule-zeromq-transport-lightweight-rpc-with-%C3%B8mq-and-protocol-buffers/</link>
      <pubDate>Tue, 06 Nov 2012 22:12:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2012/11/06/mule-zeromq-transport-lightweight-rpc-with-%C3%B8mq-and-protocol-buffers/</guid>
      <description>&lt;p&gt;Check out John D&amp;rsquo;Emic&amp;rsquo;s awesome&amp;nbsp;&lt;a href=&#34;http://blogs.mulesoft.org/lightweight-rpc-with-%C3%B8mq-and-protocol-buffers/&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt; demonstrating how&amp;nbsp;ØMQ and Mule could be used for exchanging stock quote data between a front-end and back-end application.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting up a Mule Proxy to Validate SOAP Requests</title>
      <link>https://claudemamo.github.io/2012/10/12/setting-up-a-mule-proxy-to-validate-soap-requests/</link>
      <pubDate>Fri, 12 Oct 2012 12:01:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2012/10/12/setting-up-a-mule-proxy-to-validate-soap-requests/</guid>
      <description>&lt;p&gt;&lt;span style=&#34;background-color: white; color: dimgrey; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 15px; line-height: 20px;&#34;&gt;Check out my latest post on the Ricston blog:&amp;nbsp;&lt;/span&gt;&lt;a href=&#34;http://ricston.com/blog/?p=2856&#34; style=&#34;background-color: white; color: #7aa5d2; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 15px; line-height: 20px; text-decoration: none;&#34;&gt;Setting up a Mule Proxy to Validate SOAP Requests&lt;/a&gt;&lt;span style=&#34;background-color: white; color: dimgrey; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 15px; line-height: 20px;&#34;&gt;.&lt;/span&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sharing an FTP service between un-clustered Mule instances</title>
      <link>https://claudemamo.github.io/2012/08/03/sharing-an-ftp-service-between-un-clustered-mule-instances/</link>
      <pubDate>Fri, 03 Aug 2012 10:15:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2012/08/03/sharing-an-ftp-service-between-un-clustered-mule-instances/</guid>
      <description>&lt;p&gt;&lt;span style=&#34;background-color: white;&#34;&gt;One notorious problem&amp;nbsp;when having Mule instances &lt;b&gt;consuming&lt;/b&gt; files from the same FTP server i&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;s that it&amp;rsquo;s possibile for two or more Mule instances&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;to concurrently download the same file. This leads to duplicate messages: Mule messages representing&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;the same file in different Mule nodes.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://3.bp.blogspot.com/-qLrIGlSH598/UBtred6AG7I/AAAAAAAAACc/hO0yhIi4h3A/s1600/ftp-server-unclustered.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;365&#34; src=&#34;http://3.bp.blogspot.com/-qLrIGlSH598/UBtred6AG7I/AAAAAAAAACc/hO0yhIi4h3A/s400/ftp-server-unclustered.png&#34; width=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;The &lt;a href=&#34;http://www.mulesoft.org/documentation/display/mmc/Mule+High+Availability+(HA)+Clusters&#34; target=&#34;_blank&#34;&gt;clustering solution&lt;/a&gt; offered by Mule EE 3.2 addresses this issue by having Mule instances&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;coordinate among each other on who will download files from the FTP server.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://4.bp.blogspot.com/-j5n01jCjpSQ/UjlbnyndVMI/AAAAAAAAAGU/XveenL_Xzqw/s1600/ftp-server-clustered-2.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;336&#34; src=&#34;http://4.bp.blogspot.com/-j5n01jCjpSQ/UjlbnyndVMI/AAAAAAAAAGU/XveenL_Xzqw/s400/ftp-server-clustered-2.png&#34; width=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;br /&gt;Clustering&amp;nbsp;introduces a&lt;span style=&#34;background-color: white;&#34;&gt;n &lt;a href=&#34;http://www.hazelcast.com/&#34; target=&#34;_blank&#34;&gt;in-memory data grid&lt;/a&gt; to your Mule nodes. A&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;n in-memory data grid adds significant complexity which is fine if you intend to use it for load balancing VM queues, share router state, etc&amp;hellip; But for me, all that complexity is un-necessary if you intend to use clustering &lt;b&gt;just for the sake&lt;/b&gt; of preventing Mule instances grabbing the same file on a FTP server. It&amp;rsquo;s like hitting a nail with a sledge-hammer.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;What&amp;rsquo;s the alternative to using a cluster?&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;The alternatives my colleagues and me came up with&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;weren&amp;rsquo;t exactly pretty and all of them involved doing some playing around inside of Mule.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;These days I&amp;rsquo;ve been travelling which gave me time to think more clearly&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;about the problem. It turns out that a potential simple solution (&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;at the expense of a small increase in latency)&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;lies outside of Mule:&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/--QVeyQCEydk/UBhjH3jSNKI/AAAAAAAAAB0/MGS5BaKGnJw/s1600/ftp-server-proxy.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;400&#34; src=&#34;http://2.bp.blogspot.com/--QVeyQCEydk/UBhjH3jSNKI/AAAAAAAAAB0/MGS5BaKGnJw/s400/ftp-server-proxy.png&#34; width=&#34;380&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;In above setup, the FTP proxy between the set of Mule instances and the FTP server is responsible for ensuring that&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;a Mule node gets served a &amp;lsquo;free&amp;rsquo; file. S&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;uch a solution should be relatively easy to develop and add little complexity&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;compared to others, right? To be sure, I set about implementing the &lt;a href=&#34;https://github.com/claudemamo/mule-ftp-proxy&#34; target=&#34;_blank&#34;&gt;FTP proxy&lt;/a&gt;.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;Luckily, most of the work was already done for me. James Healey took the trouble of developing an event-driven FTP framework in Ruby: &lt;a href=&#34;https://github.com/yob/em-ftpd&#34; target=&#34;_blank&#34;&gt;em-ftpd&lt;/a&gt;. All I had to do was to add callbacks which corresponded to FTP actions (e.g., ls, get, size, etc&amp;hellip;). After a couple of hours I got a &lt;b&gt;naive&lt;/b&gt; implementation up and running:&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/3215625.js?file=driver.rb&#34;&gt;&lt;/script&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;/span&gt;&lt;i&gt;MuleFtpProxyDriver&lt;/i&gt;&amp;nbsp;&lt;span style=&#34;background-color: white;&#34;&gt;represents a Mule FTP connection. This means that it&amp;rsquo;s&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;instantiated every time Mule attempts to do a FTP login&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;. It&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;declares two class variables:&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;i&gt;@@hidden_files&lt;/i&gt; is a list containing files Mule instances are downloading. As you will see, a Mule instance isn&amp;rsquo;t permitted to start a download on a file contained within the list. This removes the chance of having duplicate messages.&lt;/span&gt;&lt;/li&gt;&lt;br /&gt;&lt;li&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;i&gt;@@mutex&lt;/i&gt; is the lock used by the&amp;nbsp;MuleFtpProxyDriver instances to access safely &lt;i&gt;@@hidden_files&lt;/i&gt;.&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;The&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;FTP server,&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;which the proxy will relay requests to, has its details passed to&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;i&gt;MuleFtpProxyDriver&lt;/i&gt;&amp;rsquo;s constructor. The constructor&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;generates a unique ID that the&amp;nbsp;&lt;/span&gt;&lt;i&gt;MuleFtpProxyDriver&lt;/i&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&amp;nbsp;instance uses to keep track of the files it&amp;rsquo;s downloading.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;The &lt;i&gt;dir_contents&lt;/i&gt; method returns the list of files in a directory. T&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;he proxy lists only files which are &amp;lsquo;free&amp;rsquo;. Therefore, Mule doesn&amp;rsquo;t attempt the download a file that is being download since it&amp;rsquo;s hidden from view.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;In the &lt;i&gt;get_file&lt;/i&gt; method, the requested file is compared against the list of hidden files. If there is a match, the proxy tells Mule that the file is unavailable. Otherwise, it transfers the file from the FTP server to Mule.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;The &lt;i&gt;delete_file&lt;/i&gt; method, in addition to deleting the file from disk, removes the file entry from&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;i&gt;@@hiddenfiles&lt;/i&gt;. This allows a new file, with the same name as the deleted file, to be downloaded.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;The &lt;i&gt;unbind&lt;/i&gt; method is invoked whenever the FTP connection is broken or closed. It makes again visible those files which didn&amp;rsquo;t download completely.&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;background-color: white;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;As usual, instructions on configuring and running the FTP proxy are found in the &lt;a href=&#34;https://github.com/claudemamo/mule-ftp-proxy&#34; target=&#34;_blank&#34;&gt;repo&lt;/a&gt;. Try it out and l&lt;/span&gt;&lt;span style=&#34;background-color: white;&#34;&gt;et me know your thoughts about using an FTP proxy as an alternative to clustering.&lt;/span&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mule meet ZeroMQ. ZeroMQ meet Mule.</title>
      <link>https://claudemamo.github.io/2012/06/24/mule-meet-zeromq.-zeromq-meet-mule./</link>
      <pubDate>Sun, 24 Jun 2012 19:17:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2012/06/24/mule-meet-zeromq.-zeromq-meet-mule./</guid>
      <description>&lt;div style=&#34;text-align: justify;&#34;&gt;These past few weeks I&#39;ve been experimenting with &lt;a href=&#34;http://www.zeromq.org/&#34; target=&#34;_blank&#34;&gt;ZeroMQ&lt;/a&gt;&amp;nbsp;(a.k.a. ØMQ or ZMQ). I like the idea of a library that provides you the building blocks for constructing your own messaging architecture. For example, we may want to send messages to an application that might be unavailable at times. In our system, losing some messages isn&#39;t the end of the world so we don&#39;t need to have a high degree of message reliability. A common solution for this type of problem&amp;nbsp;is to introduce a message broker, such as ActiveMQ, and let the broker worry about making sure that messages are eventually delivered to the recipient. &lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/-jvsiYKjXCGI/T-bQS0ma4VI/AAAAAAAAAA0/sxARfTv_WYU/s1600/broker.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://2.bp.blogspot.com/-jvsiYKjXCGI/T-bQS0ma4VI/AAAAAAAAAA0/sxARfTv_WYU/s1600/broker.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;br /&gt;The main disadvantage of this approach is that a broker adds another hop to the path of the message. Also, a broker is another point in your distributed system where things could go wrong.&lt;br /&gt;&lt;br /&gt;Another option is to let the sender ensure that the message gets delivered to the recipient. Since guaranteed message delivery isn&#39;t a requirement, we can afford to lose messages should the sender go down.&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://4.bp.blogspot.com/-Soh2smSKhXg/T-bP-1L4EtI/AAAAAAAAAAs/iSMt6QaW7oE/s1600/without-broker.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;111&#34; src=&#34;http://4.bp.blogspot.com/-Soh2smSKhXg/T-bP-1L4EtI/AAAAAAAAAAs/iSMt6QaW7oE/s400/without-broker.png&#34; width=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;br /&gt;&lt;/div&gt;Using &lt;span class=&#34;Apple-style-span&#34;&gt;ØMQ&#39;s &lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;asynchronous socket-like API, we can easily implement this scenario in a few minutes.&lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt; All we need is to submit the message to &lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;ØMQ, and &lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;ØMQ will deliver the message to the recipient on our behalf.&lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt; &lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;However, because &lt;/span&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;ØMQ&lt;/span&gt; has its own protocol, the library must be embedded within the sender and receiver applications.&lt;br /&gt;&lt;br /&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;&lt;/span&gt; &lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://1.bp.blogspot.com/-yMEaJrA1NTw/T-bMKfhdCoI/AAAAAAAAAAc/wnRXJ9ARTek/s1600/with-zeromq.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://1.bp.blogspot.com/-yMEaJrA1NTw/T-bMKfhdCoI/AAAAAAAAAAc/wnRXJ9ARTek/s1600/with-zeromq.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;This simple example just scratches the surface of what you can do with&amp;nbsp;ØMQ. Real-world applications require the architecture to scale and&amp;nbsp;ØMQ offers building blocks to tackle this challenge. Consult the&amp;nbsp;&lt;a href=&#34;http://zguide.zeromq.org/page:all&#34; target=&#34;_blank&#34;&gt;ØMQ guide&lt;/a&gt; to learn more.&lt;br /&gt;&lt;br /&gt;How does &lt;a href=&#34;http://www.mulesoft.org/&#34; target=&#34;_blank&#34;&gt;Mule&lt;/a&gt;, an integration framework, fit in with&amp;nbsp;ØMQ? Well, one simple use-case is that even though&amp;nbsp;the back-end is talking in ØMQ, the outside world is speaking in a standard language such as HTTP. Mule can serve as the bridge between the outside world and the&amp;nbsp;ØMQ back-end as shown below:&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://1.bp.blogspot.com/-1Qh9s-cMbck/T-bmdPfVmXI/AAAAAAAAABA/piTeyOZ-fdo/s1600/mule-zeromq.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://1.bp.blogspot.com/-1Qh9s-cMbck/T-bmdPfVmXI/AAAAAAAAABA/piTeyOZ-fdo/s1600/mule-zeromq.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;On my &lt;a href=&#34;https://github.com/claudemamo/mule-transport-zeromq/&#34; target=&#34;_blank&#34;&gt;GitHub page,&lt;/a&gt; you&#39;ll find the first release of the Mule 3 ZeroMQ Transport for ZeroMQ 2.2. This transport frees you from having to know all the details of ØMQ&#39;s API. Furthermore, you don&#39;t need to worry about processing messages concurrently: the transport takes care of that.&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-request-response.xml&#34;&gt;&lt;/script&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;This snippet is all that it takes to implement the bridge in Mule. Those of you who are familiar with&amp;nbsp;&lt;/span&gt;Ø&lt;span class=&#34;Apple-style-span&#34;&gt;MQ API should find the &lt;i&gt;zeromq:outbound-endpoint&lt;/i&gt; easy to understand. The outbound-endpoint is telling&amp;nbsp;&lt;/span&gt;Ø&lt;span class=&#34;Apple-style-span&#34;&gt;MQ to &#34;connect&#34; to the receiver 192.168.34.10 listening on port 9090. All of this will happen once, at initialisation time. At run-time, the outbound-endpoint will transform messages to arrays of bytes and send them off to the receiver. Replies are returned by the outbound-endpoint as arrays of bytes.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;The exchange pattern &lt;i&gt;request-response&lt;/i&gt; is just one of several exchange patterns the&amp;nbsp;&lt;/span&gt;Ø&lt;span class=&#34;Apple-style-span&#34;&gt;MQ transport supports. What if we don&#39;t want to wait for the reply from the back-end? Just set the exchange pattern to &lt;i&gt;one-way&lt;/i&gt;. &lt;/span&gt;ØMQ folks, you may specify &lt;i&gt;push&lt;/i&gt; instead of &lt;i&gt;one-way&lt;/i&gt;. The same code is executed underneath.&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-one-way.xml&#34;&gt;&lt;/script&gt;Of course, it&#39;s quite possible that we have another Mule instance on the other end accepting Ø&lt;span class=&#34;Apple-style-span&#34;&gt;MQ messages as shown below:&lt;/span&gt; &lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/2941235.js?file=mule-config-inbound-request-response.xml&#34;&gt;&lt;/script&gt;Apart from different exchange patterns (see the project&#39;s &lt;a href=&#34;https://github.com/claudemamo/mule-transport-zeromq/blob/master/README.md&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;README&lt;/i&gt;&lt;/a&gt; for the complete list of supported exchange patterns) and socket operations (i.e., &lt;i&gt;connect&lt;/i&gt; and &lt;i&gt;bind&lt;/i&gt;), the transport also supports multi-part messages. In the event a Ø&lt;span class=&#34;Apple-style-span&#34;&gt;MQ inbound-endpoint receives a multi-part message, a &lt;i&gt;java.util.List&lt;/i&gt; is spit out. Each element in the list is a byte array representing a message part.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/2941235.js?file=mule-config-inbound-multipart.xml&#34;&gt;&lt;/script&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;The outbound-endpoint works a little different when it comes to multi-part messages. To send a multi-part message, the &lt;i&gt;multipart&lt;/i&gt; attribute must be set to true on the outbound-endpoint. Additionally, the message must be a &lt;i&gt;java.util.List&lt;/i&gt; where each element represents a message part.&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;Apple-style-span&#34;&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/2941235.js?file=mule-config-outbound-multipart.xml&#34;&gt;&lt;/script&gt;Let me know how you find this transport and how it may be improved. Code contributions are more than welcome :-). Future releases of the transport will support missing features such as durable sockets so keep an eye on the repo.&lt;/span&gt;&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>