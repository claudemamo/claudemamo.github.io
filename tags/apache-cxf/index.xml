<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apache Cxf on On Code &amp; Design</title>
    <link>http://www.oncodesign.io/tags/apache-cxf/</link>
    <description>Recent content in Apache Cxf on On Code &amp; Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2013 20:07:00 +0000</lastBuildDate>
    <atom:link href="http://www.oncodesign.io/tags/apache-cxf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JRuby CXF: A Gem for Creating SOAP Web Services</title>
      <link>http://www.oncodesign.io/2013/08/10/jruby-cxf-a-gem-for-creating-soap-web-services/</link>
      <pubDate>Sat, 10 Aug 2013 20:07:00 +0000</pubDate>
      
      <guid>http://www.oncodesign.io/2013/08/10/jruby-cxf-a-gem-for-creating-soap-web-services/</guid>
      <description>&lt;p&gt;It seems to me that &lt;a href=&#34;http://www.w3.org/TR/ws-arch/&#34; target=&#34;_blank&#34;&gt;Web Services&lt;/a&gt; don&amp;rsquo;t receive much love from Rubyists. In fact, of the two Ruby projects I know that add Web Service support (&lt;a href=&#34;http://rubygems.org/gems/soap4r&#34; rel=&#34;&#34; target=&#34;_blank&#34;&gt;SOAP4R&lt;/a&gt; and &lt;a href=&#34;http://rubygems.org/gems/actionwebservice&#34; target=&#34;_blank&#34;&gt;ActionWebService&lt;/a&gt;), both appear to be inactive. Someone might say that if Web Services are a must, then avoid Ruby or put an &lt;a href=&#34;http://www.mulesoft.org/&#34; target=&#34;_blank&#34;&gt;integration layer&lt;/a&gt; between your Ruby application and the client/service. From my experience, life is not always that simple and these solutions might not be applicable.&amp;nbsp; &lt;br /&gt;&lt;br /&gt;The Java ecosystem has a popular and well-supported open source project that is used to build SOAP Web Services and clients. This project is called &lt;a href=&#34;http://cxf.apache.org/&#34; target=&#34;_blank&#34;&gt;Apache CXF&lt;/a&gt;. On one fine sunny day I asked myself: &amp;ldquo;Wouldn&amp;rsquo;t it be great if I could publish a Web Service from Ruby using Apache CXF?&amp;rdquo;. Almost immediately I put that thought away. Trying to integrate a Java library into Ruby is, well, hard in my books. But then&amp;nbsp;&lt;a href=&#34;http://jruby.org/&#34; target=&#34;_blank&#34;&gt;JRuby&lt;/a&gt; popped into my mind. JRuby is the Ruby language implemented in Java. This means that Ruby and Java objects talk to each other with relative ease.&lt;br /&gt;&lt;br /&gt;Seeing the potential in the idea, last week I set about developing a &lt;a href=&#34;https://github.com/claudemamo/jruby-cxf&#34; target=&#34;_blank&#34;&gt;JRuby wrapper gem&lt;/a&gt; for CXF. I must admit it was more challenging than I thought but at the end I was happy with the results. The bulk of the work was customising the &lt;a href=&#34;http://cxf.apache.org/docs/aegis-21.html&#34; target=&#34;_blank&#34;&gt;Aegis data binder&lt;/a&gt; so that it could map &lt;i&gt;&lt;a href=&#34;http://jruby.org/apidocs/org/jruby/RubyObject.html&#34; target=&#34;_blank&#34;&gt;RubyObject&lt;/a&gt;&lt;/i&gt; instances.&lt;br /&gt;&lt;br /&gt;The first step to using the gem is installing it:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=install.sh&#34;&gt;&lt;/script&gt;A &lt;a href=&#34;https://github.com/claudemamo/jruby-cxf-example&#34; target=&#34;_blank&#34;&gt;code example&lt;/a&gt; is in order here:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(1).rb&#34;&gt;&lt;/script&gt;Publishing the above class as a Web Service means requiring the gem and including the module &lt;i&gt;CXF::WebServiceServlet&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(2).rb&#34;&gt;&lt;/script&gt;Including &lt;i&gt;WebServiceServlet&lt;/i&gt; causes the class to become a regular Java servlet. This implies that any servlet container can load the Web Service. For this example, I&amp;rsquo;ll load the Web Service using an embedded Jetty:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(3).rb&#34;&gt;&lt;/script&gt;Running the example requires two libraries to be available in the Java classpath: &lt;a href=&#34;http://archive.apache.org/dist/cxf/2.7.6/&#34; target=&#34;_blank&#34;&gt;CXF&amp;nbsp;2.7.6&lt;/a&gt; and &lt;a href=&#34;http://mirror17.pcbsd.org/Mirrors/eclipse/jetty/8.1.12.v20130726/dist/&#34; target=&#34;_blank&#34;&gt;Jetty&amp;nbsp;8&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=run-example.sh&#34;&gt;&lt;/script&gt;Accessing the URL &lt;i&gt;&lt;a href=&#34;http://localhost:8080/hello-world?wsdl&#34;&gt;http://localhost:8080/hello-world?wsdl&lt;/a&gt;&lt;/i&gt; with a browser will display the following WSDL:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=hello-world(1).wsdl&#34;&gt;&lt;/script&gt;You&amp;rsquo;ll note that the operations are missing from the WSDL. This is because I didn&amp;rsquo;t tell CXF to expose any of the methods in the class &lt;i&gt;HelloWorld&lt;/i&gt; as Web Service operations. Let me do that now:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(4).rb&#34;&gt;&lt;/script&gt;&lt;i&gt;expose&lt;/i&gt;&amp;nbsp;tells CXF to publish the method denoted by the first argument (i.e., &lt;i&gt;:say_hello&lt;/i&gt;). The second argument in &lt;i&gt;expose&lt;/i&gt; is a map. It should have at a&amp;nbsp;&lt;b&gt;minimum&lt;/b&gt; the following entries:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;&amp;nbsp;&lt;i&gt;expects&lt;/i&gt;&amp;nbsp;- maps to an ordered list of hashes where each hash corresponds to a method parameter and its expected type.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;&amp;nbsp;&lt;i&gt;returns&lt;/i&gt;&amp;nbsp;- maps to the expected return type (e.g., &lt;i&gt;:string&lt;/i&gt;).&lt;/li&gt;&lt;/ol&gt;Re-executing the example will give out this WSDL:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=hello-world(2).wsdl&#34;&gt;&lt;/script&gt;The gem supports various options to customise the WSDL. For instance, the service name and namespace can be changed:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(5).rb&#34;&gt;&lt;/script&gt;The complete list of options is found in the project repository&amp;rsquo;s&amp;nbsp;&lt;i&gt;&lt;a href=&#34;https://github.com/claudemamo/jruby-cxf/blob/master/README.md&#34; target=&#34;_blank&#34;&gt;README&lt;/a&gt;&lt;/i&gt;&amp;nbsp;file&amp;nbsp;.&lt;br /&gt;&lt;br /&gt;Till now I&amp;rsquo;ve assumed that a Web Service operation will only accept simple types. In the real world we&amp;rsquo;re more likely to be using complex types:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6176537.js?file=example(6).rb&#34;&gt;&lt;/script&gt;I&amp;rsquo;ve added two classes in the example: &lt;i&gt;Animal&lt;/i&gt; and &lt;i&gt;Person&lt;/i&gt;.&amp;nbsp;It is necessary to include the &lt;i&gt;CXF::ComplexType&lt;/i&gt; module so that CXF can derive an XML schema from these classes and embed the schema in the WSDL. A complex type element is declared using the method &lt;i&gt;member&lt;/i&gt;. A&amp;nbsp;&lt;i&gt;member&lt;/i&gt;&amp;nbsp;needs at least a name for the element and its type. You could also declare whether a property is required as seen in the member &lt;i&gt;pet&lt;/i&gt;. The &lt;i&gt;required&lt;/i&gt; option defaults to true if not specified.&lt;br /&gt;&lt;br /&gt;Note that now &lt;i&gt;say_hello&lt;/i&gt;&amp;nbsp;and&amp;nbsp;&lt;i&gt;give_age &lt;/i&gt;are&amp;nbsp;expecting a&amp;nbsp;&lt;i&gt;Person&lt;/i&gt;&amp;nbsp;object instead of primitive types and they are accessing the object via accessors. Behind the scenes the gem creates an accessor for each member that is declared.&lt;br /&gt;&lt;br /&gt;I hope I&amp;rsquo;ve given you enough info to get started out with the gem. My plan is maintain JRuby CXF as I believe it could be useful for those who aren&amp;rsquo;t happy with the current alternatives. Of course, if you find an issue with the gem, I&amp;rsquo;d be more than happy to accept code contributions ;-).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOAP over ZeroMQ with Apache CXF</title>
      <link>http://www.oncodesign.io/2013/01/15/soap-over-zeromq-with-apache-cxf/</link>
      <pubDate>Tue, 15 Jan 2013 22:28:00 +0000</pubDate>
      
      <guid>http://www.oncodesign.io/2013/01/15/soap-over-zeromq-with-apache-cxf/</guid>
      <description>&lt;p&gt;You&amp;rsquo;re probably asking yourself&amp;nbsp;one of these two questions on reading this post&amp;rsquo;s title:&lt;br /&gt;&lt;div&gt;&lt;ol&gt;&lt;li&gt;Who in his right mind would use SOAP as a data format for &lt;a href=&#34;http://www.zeromq.org/&#34; target=&#34;_blank&#34;&gt;ØMQ&lt;/a&gt;?&lt;/li&gt;&lt;li&gt;Why the heck would I want to have SOAP on top of ØMQ as opposed to HTTP?&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;For the first question, consider a system requiring:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;A &lt;a href=&#34;http://www.eaipatterns.com/ReturnAddress.html&#34; target=&#34;_blank&#34;&gt;return address&lt;/a&gt; pattern such as the one offered by &lt;a href=&#34;http://en.wikipedia.org/wiki/Java_Message_Service&#34; target=&#34;_blank&#34;&gt;JMS&lt;/a&gt;&amp;nbsp;and &lt;a href=&#34;http://en.wikipedia.org/wiki/Microsoft_Message_Queuing&#34; target=&#34;_blank&#34;&gt;MSMQ&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Guaranteed message delivery.&amp;nbsp;&lt;/li&gt;&lt;li&gt;Encryption and authentication of messages.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;ØMQ wasn&amp;rsquo;t designed to cover these requirements so it&amp;rsquo;s up to the developer to come up with a solution.&amp;nbsp;The developer can re-invent the wheel and build the solution from the ground up. But why do that when other folks have already taken the trouble of writing and implementing standards that address these concerns independent of the transport used? I&amp;rsquo;m speaking of WS-&lt;em&gt;.&amp;nbsp;Using a SOAP engine, we can leverage WS-&lt;/em&gt; standards like WS-Addressing, WS-Security, and WS-ReliableMessaging to address the above requirements and more.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;div&gt;Focusing on the second question, several motivations exist for using SOAP on top of ØMQ.&amp;nbsp;The first that may pop into mind is the desire to reduce latency as&amp;nbsp;ØMQ&amp;nbsp;incurs less overhead than HTTP.&amp;nbsp;For me, strong motivations include:&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;Leveraging ØMQ&amp;rsquo;s low-level and high-level patterns such as publish-subscribe and pipeline.&amp;nbsp;&lt;/li&gt;&lt;li&gt;Dispatching messages to services while they&amp;rsquo;re in a disconnected state.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;With the &amp;ldquo;Why?&amp;rdquo; out of the way, let&amp;rsquo;s figure out the &amp;ldquo;How?&amp;rdquo;. That is, how to process SOAP messages over ØMQ. &lt;a href=&#34;http://cxf.apache.org/&#34; target=&#34;_blank&#34;&gt;Apache CXF&lt;/a&gt; is an open-source Java SOAP engine that operates over transports such as JMS, UDP, and of course HTTP. During the holidays, since I had lot of free time on my hands ;-), I extended CXF to support &lt;a href=&#34;https://github.com/claudemamo/cxf-rt-transports-zeromq&#34; target=&#34;_blank&#34;&gt;ØMQ as an additional transport&lt;/a&gt;.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;What follows is an example of a Web Service and a client talking with each other over the transport [1]. Consider this WSDL fragment that I wrote, and which the service and client are based on:&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=hello_world.wsdl&#34;&gt;&lt;/script&gt;&lt;/div&gt;&lt;div&gt;The contract describes a service that publishes a single operation called &lt;i&gt;sayHi&lt;/i&gt;. &lt;i&gt;sayHi&lt;/i&gt; accepts an empty message and returns a string.&amp;nbsp;Line 29 of the WSDL informs us that the service expects &lt;i&gt;sayHi&lt;/i&gt; to be invoked using SOAP over ØMQ. Line 43 tells us the service address whereas lines 44-45 give additional&amp;nbsp;necessary&amp;nbsp;details for the client and service to establish communication. Observe that I&amp;rsquo;m using socket types &lt;i&gt;req&lt;/i&gt;&amp;nbsp;and &lt;i&gt;rep&lt;/i&gt; for the client and service respectively. This means that the communication between client and service occurs in RPC-style.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;I use the&amp;nbsp;the&amp;nbsp;&lt;i&gt;wsdl2java&lt;/i&gt;&amp;nbsp;tool that comes with the Apache CXF distribution to generate SEI and proxy classes from the above WSDL. These classes help me develop the WSDL service implementation and the client.&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=generate.sh&#34;&gt;&lt;/script&gt;&lt;/div&gt;Next, I implement the service:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=GreeterImpl.java&#34;&gt;&lt;/script&gt;The service is published using the following code:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=Server.java&#34;&gt;&lt;/script&gt;From the consumer-side, here&amp;rsquo;s the code:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=Client.java&#34;&gt;&lt;/script&gt;I write an additional class that triggers the execution of the service and its consumer:&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=Main.java&#34;&gt;&lt;/script&gt;&lt;/div&gt;&lt;div&gt;I use Maven from the project&amp;rsquo;s root directory to build the example:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=build.sh&#34;&gt;&lt;/script&gt;Finally, to run the app:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=run.sh&#34;&gt;&lt;/script&gt;The output I get is:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4540611.js?file=gistfile1.txt&#34;&gt;&lt;/script&gt;You&amp;rsquo;ll find the complete &lt;a href=&#34;https://github.com/claudemamo/zmq-soap&#34; target=&#34;_blank&#34;&gt;example&lt;/a&gt; on GitHub.&amp;nbsp;This example is basic; its purpose is to get you up and running with the transport. In my next post I&amp;rsquo;ll have a more real-world example where I&amp;rsquo;ll show how WS-Addressing&amp;rsquo;s ReplyTo element is be leveraged to implement the return address pattern in&amp;nbsp;ØMQ.&lt;br /&gt;&lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;span style=&#34;font-family: Times, Times New Roman, serif; font-size: small;&#34;&gt;&lt;span class=&#34;num&#34;&gt;1:&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Times, Times New Roman, serif;&#34;&gt;You need the &lt;a href=&#34;https://github.com/zeromq/jzmq/archive/2.1.0.tar.gz&#34; target=&#34;_blank&#34;&gt;Java binding for ØMQ&lt;/a&gt;&amp;nbsp;installed on your machine to run the example.&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>