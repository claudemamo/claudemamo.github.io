<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on On Code &amp; Design</title>
    <link>https://claudemamo.github.io/tags/java/</link>
    <description>Recent content in Java on On Code &amp; Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Nov 2015 13:42:00 +0000</lastBuildDate>
    <atom:link href="https://claudemamo.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing a Replicated Token Service with JSON Web Tokens</title>
      <link>https://claudemamo.github.io/2015/11/09/implementing-a-replicated-token-service-with-json-web-tokens/</link>
      <pubDate>Mon, 09 Nov 2015 13:42:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2015/11/09/implementing-a-replicated-token-service-with-json-web-tokens/</guid>
      <description>&lt;div&gt;Last week I observed one of the 8 fallacies of distributed systems in action:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;i&gt;&#34;Topology doesn&#39;t change&#34;&lt;/i&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div&gt;A client of mine deployed the latest versions of his web services to a highly-available QA environment. Sanity tests gave initial confirmation that the system was behaving as expected. But then, the QA team reported weird behaviour in the system&#39;s offline functionality. So I was called in the figure out the problem. The logs showed an application getting random HTTP 401s from the system&#39;s token service.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This token service is a Java web application that creates and verifies &lt;a href=&#34;http://jwt.io/&#34; target=&#34;_blank&#34;&gt;JSON Web Tokens&lt;/a&gt; (JWTs). A client receives a 200 HTTP OK from the service for a token passing verification. Otherwise, it receives a 401 HTTP Unauthorized code. On startup, the token service creates a public/private key pair (PPK) &amp;nbsp;in-memory&amp;nbsp;for signing and verifying these tokens. I knew the token service in QA was replicated and requests to replicas were load-balanced in a round-robin fashion. This quickly led me to the realisation that the issue occurred when (1) a replica of the token service verified a token with its own public key and (2) the same token was created as well signed by a different replica with its own private key. This issue wasn&#39;t caught in the developer&#39;s testing environment because services weren&#39;t replicated.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I&#39;m going to describe a solution I implemented for this problem because, though it&#39;s simple to program, such a solution might not be obvious. All shown code is in Java or SQL but it should be relatively easy to adapt the code to the technologies of your choice.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;At an abstract level, the solution is to have each token service replica&#39;s public key and key ID visible to all other replicas. In addition to making the key ID visible to the set of replicas, the signer embeds the key ID in the created token before signing it with its own private key. This allows the verifier to know which public key to use for verifying the token. When the token service accepts a request to verify a token, it extracts the key ID from the token to lookup the public key to use for verifying it. Security-wise, this approach enables us to keep the private key secret with respect to the other token service replicas.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Now let&#39;s delve into the details. Given that the token service replicas share a database, I re-use the database to share the public keys and key IDs between replicas. In a relational database context, the schema for holding such information might look like this:&lt;/div&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=schema.sql&#34;&gt;&lt;/script&gt;&lt;ol&gt;&lt;li&gt;&lt;i&gt;nodeId&lt;/i&gt; is a UUID representing the replica owning the table row. This enables me to delete&amp;nbsp;the row owned by a replica when it gracefully shuts down, reducing, but not eliminating, the likelihood of orphan records.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;&lt;i&gt;name&lt;/i&gt; identifies the type of configuration. Although in this solution I&#39;m only storing the public key in the table, you might want to store other configurations.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;&lt;i&gt;value_&lt;/i&gt; is where I store the actual public key along with the key ID.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;In the token service, I use&amp;nbsp;&lt;a href=&#34;https://bitbucket.org/b_c/jose4j/wiki/Home&#34; target=&#34;_blank&#34;&gt;jose.4.j&lt;/a&gt;&amp;nbsp;0.4.4, an open-source Java implementation of JWT, for generating and verifying tokens. Before I can go on to generate/verify a token, first I need create a PPK and register the public key, including its key ID, so that it can be read by other replicas:&lt;/div&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=Listener(1).java&#34;&gt;&lt;/script&gt;The above code is executed at startup and merits a brief explanation:&lt;br /&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;Line 7-8&lt;i&gt;: RsaJwkGenerator.generateJwk(2048)&lt;/i&gt; returns a 2048-bit PPK. The key ID for the PPK is set to the node ID which is simply a UUID created as well at startup.&lt;br /&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;Line 9:&amp;nbsp;&lt;i&gt;ConfigurationDataMapper.insertConfiguration(...)&lt;/i&gt; registers the public key by adding a record to the database table &lt;i&gt;Configuration&lt;/i&gt;. Its parameters map to the table columns&amp;nbsp;&lt;i&gt;nodeId&lt;/i&gt;, &lt;i&gt;name&lt;/i&gt;, and &lt;i&gt;value_,&lt;/i&gt;&amp;nbsp;respectively.&lt;br /&gt;&lt;i&gt;&lt;br /&gt;&lt;/i&gt;Line 9:&amp;nbsp;&lt;i&gt;rsaJsonWebKey.toJson() &lt;/i&gt;does the job of serialising the public key and key ID to JSON for us. Note the&amp;nbsp;&lt;i&gt;toJson()&lt;/i&gt;&amp;nbsp;method does NOT include the private key in the returned JSON.&lt;br /&gt;&lt;br /&gt;Line 10: Finally, the PPK is saved in the service&#39;s context in order to read the private key later on for signing the token.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;As mentioned above, the token service creates signed tokens for clients. The code for this is implemented in the &lt;i&gt;createToken(...)&lt;/i&gt; method:&lt;/div&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=TokenFactory.java&#34;&gt;&lt;/script&gt;I blatantly copied the code from&amp;nbsp;jose.4.j&#39;s excellent &lt;a href=&#34;https://bitbucket.org/b_c/jose4j/wiki/JWT%20Examples&#34; target=&#34;_blank&#34;&gt;examples page&lt;/a&gt; from where you can find an explanation of what it does.&amp;nbsp;However, I want to highlight that I&#39;m passing the PPK I saved earlier in the service context to &lt;i&gt;createToken(...)&lt;/i&gt;. Additionally, observe that on line 16 I&#39;m setting the token&#39;s key ID to the PPK&#39;s key ID which is the node ID.&lt;br /&gt;&lt;br /&gt;&lt;div&gt;On receiving a request to verify a token, the service fetches all registered public keys and key IDs from the database before verifying the token [1]:&lt;/div&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=TokenService(1).java&#34;&gt;&lt;/script&gt;&lt;div&gt;In the above method, the public keys are (1) re-constructed from the JSON persisted to the database and (2) added to a list. The list is passed to the &lt;i&gt;isValid(...)&lt;/i&gt; method along with the token. i&lt;i&gt;sValid(...)&lt;/i&gt;&amp;nbsp;returns true if a token passes verification, otherwise false:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=TokenService(2).java&#34;&gt;&lt;/script&gt;In &lt;i&gt;isValid(...)&lt;/i&gt;, I pass the list of public keys to the&amp;nbsp;&lt;i&gt;JwksVerificationKeyResolver&lt;/i&gt;&amp;nbsp;class constructor to create an object that resolves the public key to use for verifying the token according to the key ID extracted from the received token. The rest of the code builds a&amp;nbsp;&lt;i&gt;JwtConsumer&lt;/i&gt;&amp;nbsp;object to verify the token.&lt;br /&gt;&lt;br /&gt;The last item to tackle is to have a token service replica, that is shutting down gracefully, delete its public key from the configuration table:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/37732487df6f59fc7177.js?file=Listener(2).java&#34;&gt;&lt;/script&gt;This is required because the replica&#39;s private key and node ID are kept in-memory and therefore lost on shutdown. Of course, this isn&#39;t a foolproof way of eliminating orphan records. Furthermore, it&#39;s possible that a token signed by a replica is still in circulation after the replica has shutdown causing the token to fail verification. I&#39;ll leave these problems as exercises for the reader to solve.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;span class=&#34;num&#34; style=&#34;font-family: &amp;quot;times&amp;quot; , &amp;quot;times new roman&amp;quot; , serif;&#34;&gt;1: &lt;i&gt;createToken(...)&lt;/i&gt; definitely has room for improvement in terms of performance.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The Trials of Smooks</title>
      <link>https://claudemamo.github.io/2014/09/16/the-trials-of-smooks/</link>
      <pubDate>Tue, 16 Sep 2014 17:28:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2014/09/16/the-trials-of-smooks/</guid>
      <description>&lt;p&gt;The fact that I&amp;rsquo;m a hard to please guy explains why I rarely show appreciation for a tool. I easily get frustrated when a tool fails to meet the challenges it&amp;rsquo;s meant to solve. &lt;a href=&#34;http://www.smooks.org/&#34; target=&#34;_blank&#34;&gt;Smooks&lt;/a&gt; is one of the few tools I appreciate. It&amp;rsquo;s an invaluable transformation framework in the integrator&amp;rsquo;s arsenal. On a project I was on, I threw at Smooks [1] all manner of challenges, and one after another, Smooks overcame them without giving up a key requirement: &lt;b&gt;maintaining a low memory overhead during transformation&lt;/b&gt;. A shoutout to &lt;a href=&#34;http://www.smooks.org/mediawiki/index.php?title=Smooks_Team&#34; target=&#34;_blank&#34;&gt;Tom Fennelly and his team&lt;/a&gt; for bringing to us such a fantastic tool.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;&lt;b&gt;Trial I&lt;/b&gt;&lt;/h3&gt;&lt;br /&gt;The initial challenge I brought to Smooks was about taking a tilde delimited CSV file and map its records to POJOs:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=products.csv&#34;&gt;&lt;/script&gt;You can see the file has an unorthodox header in addition to a footer. Using Smooks&amp;rsquo;s built-in CSV &lt;b&gt;reader&lt;/b&gt;, I wrote concisely the Smooks config doing the mapping to POJOs:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=csv-to-pojos.xml&#34;&gt;&lt;/script&gt;What&amp;rsquo;s happening under the covers, and in general, is that the reader pulls data from a &lt;b&gt;source&lt;/b&gt; (e.g., &lt;i&gt;java.io.InputStream&lt;/i&gt;) to go on to produce a stream of SAX events. The reader I&amp;rsquo;m using above is expecting the source data to be structured as CSV and to consist of 4 columns. Let&amp;rsquo;s make things more concrete. Reading from the &lt;i&gt;products.csv&lt;/i&gt; file, the reader produces the following XML stream [2]:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=products-xml-stream.xml&#34;&gt;&lt;/script&gt;Listening to the stream of SAX events is the &lt;b&gt;visitor&lt;/b&gt;. A visitor listens to specific events from the stream to fire some kind of behaviour, typically transformation. With the&amp;nbsp;&lt;i&gt;singleBinding&lt;/i&gt;&amp;nbsp;element in the&amp;nbsp;&lt;i&gt;csv-to-pojos.xml&lt;/i&gt; config, the CSV reader pre-configures a JavaBean&amp;nbsp;visitor to listen for&amp;nbsp;&lt;i&gt;csv-record&lt;/i&gt; elements. On intercepting this element, the JavaBean visitor instantiates a&amp;nbsp;&lt;i&gt;org.ossandme.Product&lt;/i&gt;&amp;nbsp;object and binds its properties to &lt;i&gt;csv-record&lt;/i&gt;&amp;rsquo;s children element content. You&amp;rsquo;ll notice that I left&amp;nbsp;&lt;i&gt;Product&amp;rsquo;s&amp;nbsp;&lt;/i&gt;target properties unspecified in the config. The CSV reader assumes&amp;nbsp;&lt;i&gt;Product&lt;/i&gt;&amp;nbsp;follows JavaBean conventions and its properties are named the same as the defined CSV columns. Records disobeying the column definition are ignored. Consequently, I do not need to worry about the file&amp;rsquo;s header and footer.&lt;br /&gt;&lt;br /&gt;With the transformation configuration out of the way, I turned my attention to running the transformation on the CSV file from my Java code and process the &lt;i&gt;Product&lt;/i&gt; objects as they are instantiated and bound by Smooks:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=CsvToPojosTransformer.java&#34;&gt;&lt;/script&gt; &lt;br /&gt;&lt;h3&gt;&lt;b&gt;Trial II&lt;/b&gt;&lt;/h3&gt;&lt;br /&gt;A more complex transformation task I gave to Smooks was to load file records, holding a variable number of columns, into a database. As in the previous task, this file had a header as well as a footer:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions.csv&#34;&gt;&lt;/script&gt;You&amp;rsquo;ll observe in the sample CSV file that records could be one of three types as denoted by the first column: &lt;i&gt;TH&lt;/i&gt;, &lt;i&gt;TB&lt;/i&gt; or &lt;i&gt;TF&lt;/i&gt;. The CSV reader, as it transforms and pushes records to the XML stream, can be customised such that it renames the&amp;nbsp;&lt;i&gt;csv-record&lt;/i&gt;&amp;nbsp;holder to the record&amp;rsquo;s primary column:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(1).xml&#34;&gt;&lt;/script&gt;As we&amp;rsquo;ll see later, the above config permits Smooks to distinguish between the different record types. Given the sample file &lt;i&gt;transactions.csv&lt;/i&gt;, the reader I&amp;rsquo;ve configured produces the following stream:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-xml-stream.xml&#34;&gt;&lt;/script&gt;&lt;i&gt;UNMATCHED&lt;/i&gt;&amp;nbsp;elements represent the file&amp;rsquo;s header and footer. A CSV record having &lt;i&gt;TH&lt;/i&gt; in the first field will trigger the reader to create a &lt;i&gt;TH&lt;/i&gt; element holding the other record fields. The same logic goes for&amp;nbsp;&lt;i&gt;TB&lt;/i&gt; and &lt;i&gt;TF&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;Database visitors load the records. However, since these visitors are limited to binding data from POJOs, I first must turn the XML mapped records from the stream into said POJOs. The CSV reader doesn&amp;rsquo;t know how to bind variable field records to POJOs so I configure the mapping myself:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(2).xml&#34;&gt;&lt;/script&gt;Given what we&amp;rsquo;ve learnt about Smooks, we can deduce what&amp;rsquo;s happening here. The JavaBean visitor for lines 10 till 17 has a &lt;b&gt;selector&lt;/b&gt; (i.e, &lt;i&gt;createOnElement&lt;/i&gt;)&amp;nbsp;for the element&amp;nbsp;&lt;i&gt;TH&lt;/i&gt;. A selector is&amp;nbsp;a quasi XPath expression applied on XML elements as they come through the stream. On viewing&amp;nbsp;&lt;i&gt;TH&lt;/i&gt;, the visitor will:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Instantiate a &lt;i&gt;HashMap&lt;/i&gt;.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Iterate through the &lt;i&gt;TH&lt;/i&gt; fragment. If an element inside the fragment matches the selector set in a &lt;i&gt;data&lt;/i&gt; attribute, then (a) a map entry is created, (b) bound to the element content, and &amp;copy; put in the map.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Add the map to the Smooks bean context which is identified by the name set in &lt;i&gt;beanID&lt;/i&gt;. The map overwrites any previous map in the context with the same ID. This makes sense since we want to prevent objects from accumulating in memory.&lt;/li&gt;&lt;/ol&gt;The database visitors reference the maps in the bean context:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(3).xml&#34;&gt;&lt;/script&gt;The insert statements are bound to the map entry values and are executed &lt;b&gt;after&lt;/b&gt;&amp;nbsp;the element, the &lt;i&gt;executeOnElement&lt;/i&gt; selector points to, is processed. The next step is to configure a datasource for the database visitors (lines 47-49):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=transactions-to-db(4).xml&#34;&gt;&lt;/script&gt;Last but not least, the Java code to kick off the data load:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=CsvToDbTransformer.java&#34;&gt;&lt;/script&gt; &lt;br /&gt;&lt;h3&gt; Trial III&lt;/h3&gt;&lt;br /&gt;The next challenge for Smooks makes the previous ones look like child&amp;rsquo;s play. The goal: transform an XML stream to a CSV file that is eventually uploaded to an FTP server. The input:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=accounts-stream.xml&#34;&gt;&lt;/script&gt;The desired output:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=accounts.csv&#34;&gt;&lt;/script&gt;Considering the CSV could be large in size, my requirement was for Smooks to write the transformed content to a &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/io/PipedOutputStream.html&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;PipedOutputStream&lt;/i&gt;&lt;/a&gt;. An FTP library would read from the &lt;i&gt;PipedOutputStream&lt;/i&gt;&amp;rsquo;s connected &lt;a href=&#34;http://docs.oracle.com/javase/8/docs/api/java/io/PipedInputStream.html&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;PipedInputStream&lt;/i&gt;&lt;/a&gt;, and write the streamed content to a file. To this end, I wrote the class running the transformation as follows:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=XmlToCsvTransformer(1).java&#34;&gt;&lt;/script&gt;My focus then turned to the XML-to-CSV mapping configuration. After deliberation, I reluctantly settled to use the&amp;nbsp;&lt;a href=&#34;http://freemarker.org/&#34; target=&#34;_blank&#34;&gt;FreeMarker&lt;/a&gt; visitor for writing the CSV. I considered as an alternative to develop a visitor specialised for this type of transformation but time constraints made this unfeasible. The FreeMarker visitor, like the database one, cannot read directly off the XML stream. Instead, it can read from DOM and POJOs. So I decide to use the DOM visitor such that it creates DOMs from &lt;i&gt;record&lt;/i&gt;&amp;nbsp;elements found within the input stream:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(1).xml&#34;&gt;&lt;/script&gt;I then configured the FreeMarker visitor to apply the CSV template on seeing the element&amp;nbsp;&lt;i&gt;record&lt;/i&gt;&amp;nbsp;in the stream:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(2).xml&#34;&gt;&lt;/script&gt;Below is a simplified version of what I had in real life in&lt;i&gt;&amp;nbsp;account.ftl&lt;/i&gt;&amp;nbsp;(note the last line of the template must be a newline):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=account.ftl&#34;&gt;&lt;/script&gt;An additional complexity I had to consider were the CSV&amp;rsquo;s header and footer. Apart from being structured differently than the rest of the records, the header had to contain the current date whereas, for the footer, the total record count. What I did for the header was to bind the current date from my Java code to Smooks&amp;rsquo;s bean context (lines 27-30 and 38):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=XmlToCsvTransformer(2).java&#34;&gt;&lt;/script&gt;The date is then referenced from the Smooks config (lines 9-12):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(3).xml&#34;&gt;&lt;/script&gt;With respect to the above config, at the start of the XML stream, FreeMarker writes the header to the output stream (i.e., &lt;i&gt;PipedOutputStream&lt;/i&gt;):&lt;br /&gt;&lt;br /&gt;&lt;i&gt;000000Card Extract &amp;nbsp; &lt;/i&gt;[current date]&lt;br /&gt;&lt;br /&gt;&lt;i&gt;&amp;lt;?TEMPLATE-SPLIT-PI?&amp;gt;&lt;/i&gt;&amp;nbsp;is an embedded Smooks instruction that applies&amp;nbsp;&lt;i&gt;account.ftl&lt;/i&gt;&amp;nbsp;to &lt;i&gt;record&lt;/i&gt; elements after the header.&lt;br /&gt;&lt;br /&gt;Adding the record count to the footer is just a matter of configuring the Calculator visitor to maintain a counter in the bean context and referencing that counter from the template:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=xml-to-csv(4).xml&#34;&gt;&lt;/script&gt; &lt;br /&gt;&lt;h3&gt; Trial IV&lt;/h3&gt;&lt;br /&gt;The final challenge Smooks had to go against was to read from a&amp;nbsp;&lt;i&gt;java.util.Iterator&lt;/i&gt;&amp;nbsp;of maps and, like the previous task, write the transformed output to a stream in CSV format. Unlike the &lt;i&gt;InputStream&lt;/i&gt;&amp;nbsp;that Smooks read from the other tasks, Smooks doesn&amp;rsquo;t have a reader that is capable of writing a properly structured XML doc from an iterator of maps. So I&amp;rsquo;m left with writing my own reader:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=MapIteratorSourceReader.java&#34;&gt;&lt;/script&gt;The custom reader is hooked into Smooks as follows (line 5):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=map-iterator-to-csv.xml&#34;&gt;&lt;/script&gt;Finally, passing the iterator to Smooks for transformation consists of setting a &lt;i&gt;JavaSource&lt;/i&gt; parameter, holding the iterator, on &lt;i&gt;filterSource(&amp;hellip;)&lt;/i&gt; &amp;nbsp;(line 27):&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/e80c8add45b776e0a0a5.js?file=MapIteratorToCsvTransformer.java&#34;&gt;&lt;/script&gt; &lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;span class=&#34;num&#34; style=&#34;font-family: &amp;quot;times&amp;quot; , &amp;quot;times new roman&amp;quot; , serif;&#34;&gt;1: The Smooks version I used was 1.5.2.&lt;/span&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;span class=&#34;num&#34; style=&#34;font-family: &amp;quot;times&amp;quot; , &amp;quot;times new roman&amp;quot; , serif;&#34;&gt;2: You might be wondering how I know for certain the XML document shown is the one actually produced by Smooks. I know because of Smooks&amp;rsquo;s &lt;a href=&#34;http://www.smooks.org/mediawiki/index.php?title=V1.5:Smooks_v1.5_User_Guide#Checking_the_Smooks_Execution_Process&#34;&gt;HtmlReportGenerator&lt;/a&gt; class.&lt;/span&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Log4j 2 Memory-Mapped File Appender</title>
      <link>https://claudemamo.github.io/2013/12/23/log4j-2-memory-mapped-file-appender/</link>
      <pubDate>Mon, 23 Dec 2013 11:38:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2013/12/23/log4j-2-memory-mapped-file-appender/</guid>
      <description>&lt;p&gt;During the weekend I dug into Java NIO, specifically, mapping files to memory to reduce I/O time. What&amp;rsquo;s more, since I had a lot of free time on my hands, I developed a&amp;nbsp;&lt;a href=&#34;http://logging.apache.org/log4j/2.x/&#34; target=&#34;_blank&#34;&gt;Log4j 2&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://issues.apache.org/jira/browse/LOG4J2-431&#34; target=&#34;_blank&#34;&gt;memory-mapped file appender&lt;/a&gt;. On my machine, performance tests running on a single thread using the MemoryMappedFile appender show an improvement by a factor of 3 when compared to the&amp;nbsp;&lt;a href=&#34;http://logging.apache.org/log4j/2.x/manual/appenders.html#RandomAccessFileAppender&#34; target=&#34;_blank&#34;&gt;RandomAccessFile&lt;/a&gt;&amp;nbsp;appender.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Kafka for Event Sourcing</title>
      <link>https://claudemamo.github.io/2013/12/11/apache-kafka-for-event-sourcing/</link>
      <pubDate>Wed, 11 Dec 2013 21:01:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2013/12/11/apache-kafka-for-event-sourcing/</guid>
      <description>&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;a href=&#34;http://martinfowler.com/eaaDev/EventSourcing.html&#34; target=&#34;_blank&#34;&gt;Event Sourcing&lt;/a&gt; is a pattern intended for &#34;&lt;i&gt;capturing all changes to an application state as a sequence of events&lt;/i&gt;&#34;. As explained by Fowler, the pattern is useful when you want the ability to completely rebuild the application state, perform temporal querying, or replay events. The &lt;a href=&#34;http://www.infoq.com/presentations/LMAX&#34; target=&#34;_blank&#34;&gt;LMAX platform&lt;/a&gt; is a famous example where Event Sourcing is applied to keep all application state in-memory and consequently contributing to the system&#39;s surprisingly high throughput and low latency.&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;While investigating the architectural components of &lt;a href=&#34;http://samza.incubator.apache.org/&#34; target=&#34;_blank&#34;&gt;Samza&lt;/a&gt;, I came across a component that can be of great help when implementing Event Sourcing:&amp;nbsp;&lt;a href=&#34;https://kafka.apache.org/&#34; target=&#34;_blank&#34;&gt;Apache Kafka&lt;/a&gt;. &lt;a href=&#34;http://research.microsoft.com/en-us/um/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf&#34; target=&#34;_blank&#34;&gt;Created&lt;/a&gt; by the folks at LinkedIn as a solution to their log processing requirements, Kafka is a broker with message replay built-in.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;Kafka consumers receive messages from publish/subscribe channels known as topics. A topic is divided into user-defined partitions where a partition can serve messages only to a single consumer process. Balancing the message load between consumers is a matter of adding more partitions to the topic, assigning those partitions to other consumer instances, and finally, publishing messages to all topic partitions in a round robin fashion.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://3.bp.blogspot.com/-kvjAcN0vFfg/Uqb4m63H3_I/AAAAAAAAAGw/zJ7XrGdjiDA/s1600/kafka-concepts.png&#34; imageanchor=&#34;1&#34; style=&#34;clear: left; float: left; margin-bottom: 1em; margin-right: 1em; text-align: left;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://3.bp.blogspot.com/-kvjAcN0vFfg/Uqb4m63H3_I/AAAAAAAAAGw/zJ7XrGdjiDA/s640/kafka-concepts.png&#34; height=&#34;356&#34; width=&#34;640&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;What fascinates about Kafka is that at any point in time a consumer can rewind back through the history of messages and re-consume messages at a particular offset. In the above diagram, Consumer B can consume the latest messages or replay messages, say, starting from offset 1.&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;At face value we could be forgiven to think that a broker with in-built message replay would have trouble achieving high throughput for large message volumes. After all, Kafka is retaining&amp;nbsp;unconsumed&amp;nbsp;as well as consumed messages on disk: presumably costlier than simply keeping unconsumed messages in memory. However, a &lt;a href=&#34;http://kafka.apache.org/documentation.html#design&#34; target=&#34;_blank&#34;&gt;few&lt;/a&gt; clever design decisions, such as relying on the OS page cache and minimising random disk I/O, gave LinkedIn engineers impressive throughput results when comparing Kafka against both ActiveMQ and RabbitMQ.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;With the basic concepts and performance considerations out of the way, let me illustrate my point about Kafka&#39;s suitability for Event Sourcing by giving a &lt;a href=&#34;https://github.com/claudemamo/kafka-replays&#34; target=&#34;_blank&#34;&gt;code example&lt;/a&gt;:&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/7840143.js?file=MyProducer.java&#34;&gt;&lt;/script&gt;The above producer publishes, for a number of times, a message to the topic &lt;i&gt;ossandme &lt;/i&gt;on partition 0. In particular, it creates a message by instantiating the&amp;nbsp;&lt;i&gt;KeyedMessage&lt;/i&gt; class with the following parameters (line 19):&lt;/div&gt;&lt;/div&gt;&lt;ul&gt;&lt;li style=&#34;text-align: left;&#34;&gt;Name of the topic to which the message is published.&lt;/li&gt;&lt;li style=&#34;text-align: left;&#34;&gt;ID of the partition the message will sit on.&lt;/li&gt;&lt;li style=&#34;text-align: left;&#34;&gt;Message content, in this case, the time the message was published.&lt;/li&gt;&lt;/ul&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;The following consumer pulls messages from the&amp;nbsp;topic&amp;nbsp;&lt;i&gt;ossandme&lt;/i&gt;:&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/7840143.js?file=MyConsumer.java&#34;&gt;&lt;/script&gt;For each message received, the application outputs the message&#39;s offset on partition 0 in addition to its content (line 50). The first thing to observe is that I&#39;ve programmed against Kafka&#39;s low-level&amp;nbsp;&lt;a href=&#34;http://kafka.apache.org/documentation.html#simpleconsumerapi&#34; target=&#34;_blank&#34;&gt;SimpleConsumer&lt;/a&gt;&amp;nbsp;API. Alternatively, I could have opted for the&amp;nbsp;&lt;a href=&#34;http://kafka.apache.org/documentation.html#highlevelconsumerapi&#34; target=&#34;_blank&#34;&gt;High Level Consumer&lt;/a&gt;&amp;nbsp;API to reduce development time. I chose the former because with the latter I was unable to find a way to replay any set of messages I wanted.&amp;nbsp;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;Event Sourcing comes into play when an exception occurs. On exception, the application rewinds back to the first message in the partition and re-attempts to process all of the partition&#39;s messages (line 24). I like the fact that, to get this type of behaviour, I didn&#39;t have to introduce a database but simply leveraged the broker&#39;s message replay capability. Without a database, I&#39;ve one less moving part to think about in my architecture.&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&#34;text-align: justify;&#34;&gt;&lt;div style=&#34;text-align: left;&#34;&gt;Kafka is a young project and I&#39;m interested to see how it matures. I&#39;m keen to hear people&#39;s experiences using Kafka and whether it proved to be the right solution for them. As the project matures, I suspect we&#39;ll hear more often about Kafka in our technical discussions along with the other, more established, open source brokers.&lt;/div&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>JRuby Complex Classes in Java Method Signatures</title>
      <link>https://claudemamo.github.io/2013/08/19/jruby-complex-classes-in-java-method-signatures/</link>
      <pubDate>Mon, 19 Aug 2013 11:41:00 +0000</pubDate>
      
      <guid>https://claudemamo.github.io/2013/08/19/jruby-complex-classes-in-java-method-signatures/</guid>
      <description>&lt;p&gt;As documented in the JRuby wiki,&amp;nbsp;&lt;i&gt;&lt;a href=&#34;https://github.com/jruby/jruby/wiki/GeneratingJavaClasses#generating-java-classes-ahead-of-time&#34; target=&#34;_blank&#34;&gt;java_signature&lt;/a&gt;&lt;/i&gt;&amp;nbsp;changes a method&amp;rsquo;s signature to match the signature string passed to it:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6262775.js?file=example(1).rb&#34;&gt;&lt;/script&gt;Observe that the classes in the method signature&amp;nbsp;are primitive. What if we use a complex class as a parameter type?&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6262775.js?file=example(2).rb&#34;&gt;&lt;/script&gt;Running the above code will give you the following &lt;i&gt;NoMethodError&lt;/i&gt; message:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6262775.js?file=error&#34;&gt;&lt;/script&gt; The way I went about using complex classes in signatures is to utilise&amp;nbsp;&lt;i&gt;add_method_signature&lt;/i&gt;&amp;nbsp;instead of&amp;nbsp;&lt;i&gt;java_signature&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/6262775.js?file=example(3).rb&#34;&gt;&lt;/script&gt;&lt;i&gt;add_method_signature&lt;/i&gt;&amp;nbsp;expects the first argument to be the name of the method that will have its signature changed. For the second argument, it expects it to be a list of classes. The list&amp;rsquo;s first item is the return class (e.g.,&amp;nbsp;&lt;i&gt;void&lt;/i&gt;) while the subsequent items are the signature&amp;rsquo;s parameter classes (e.g.,&amp;nbsp;&lt;i&gt;int&lt;/i&gt; and &lt;i&gt;MyClass&lt;/i&gt;). Note that I invoke&amp;nbsp;&lt;i&gt;become_java!&lt;/i&gt;&amp;nbsp;on the complex class. This tells &lt;i&gt;MyClass&lt;/i&gt; to materialize itself into a Java class. The &lt;i&gt;false&lt;/i&gt; flag is needed so that JRuby&amp;rsquo;s main class loader is used to load the class. Without it, you&amp;rsquo;ll be greeted by a&amp;nbsp;&lt;i&gt;java.lang.ClassNotFoundException&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>