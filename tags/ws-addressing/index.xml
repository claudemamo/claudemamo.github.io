<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ws Addressing on On Code &amp; Design</title>
    <link>https://oncodesign.io/tags/ws-addressing/</link>
    <description>Recent content in Ws Addressing on On Code &amp; Design</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Jan 2013 17:22:00 +0000</lastBuildDate>
    <atom:link href="https://oncodesign.io/tags/ws-addressing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ReplyTo in ZeroMQ using WS-Addressing</title>
      <link>https://oncodesign.io/2013/01/27/replyto-in-zeromq-using-ws-addressing/</link>
      <pubDate>Sun, 27 Jan 2013 17:22:00 +0000</pubDate>
      
      <guid>https://oncodesign.io/2013/01/27/replyto-in-zeromq-using-ws-addressing/</guid>
      <description>&lt;p&gt;In my &lt;a href=&#34;http://opensourcesoftwareandme.blogspot.com/2013/01/soap-over-zeromq-with-apache-cxf.html&#34; target=&#34;_blank&#34;&gt;last post&lt;/a&gt;, I mentioned how one could leverage SOAP along with WS-Addressing to implement the &lt;a href=&#34;http://www.eaipatterns.com/ReturnAddress.html&#34; target=&#34;_blank&#34;&gt;return address pattern&lt;/a&gt; in&amp;nbsp;ØMQ&amp;nbsp;(known in the JMS world as&amp;nbsp;&lt;i&gt;ReplyTo&lt;/i&gt;&amp;nbsp;and in the MSMQ world as&amp;nbsp;&lt;i&gt;ResponseQueue&lt;/i&gt;). In this post, I&amp;rsquo;ll go into more detail by giving a code example using &lt;a href=&#34;https://github.com/claudemamo/cxf-rt-transports-zeromq&#34; target=&#34;_blank&#34;&gt;CXF&amp;rsquo;s ØMQ transport&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Below is a WSDL that is similar in many respects to the WSDL of the previous post:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=hello_world_addr.wsdl&#34;&gt;&lt;/script&gt;Like the other WSDL, this one declares that the service has an operation named &lt;i&gt;sayHi&lt;/i&gt;. It states that&amp;nbsp;ØMQ&amp;nbsp;is to be used for transporting the SOAP messages (line 29). Moreover, it declares the service and consumer communication parameters:&amp;nbsp;&lt;i&gt;zmq:address;&lt;/i&gt;&amp;nbsp;&lt;i&gt;zmq:serviceConfig;&lt;/i&gt;&amp;nbsp;&lt;i&gt;zmq:clientConfig&lt;/i&gt; (lines 43-45).&amp;nbsp;&lt;b&gt;Unlike&lt;/b&gt; the other WSDL, the socket types are &lt;i&gt;push&lt;/i&gt; for the client and &lt;i&gt;pull&lt;/i&gt; for the service. This means that communication between the client and service is one-way and therefore the client won&amp;rsquo;t receive a reply, at least not on the same channel. Remember, since we&amp;rsquo;re implementing return address, the service sends its reply onto a different channel.&lt;br /&gt;&lt;br /&gt;This is the shell command I entered for generating the SEI and proxy classes:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=generate-client.sh&#34;&gt;&lt;/script&gt;The &lt;i&gt;-asyncMethods&lt;/i&gt; switch tells CXF&amp;rsquo;s &lt;i&gt;wsdl2java&lt;/i&gt; to generate, in the SEI, for each Web Service operation an asynchronous method in addition to a synchronous one. In the consumer implementation, I use the generated SEI:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=Client.java&#34;&gt;&lt;/script&gt;&lt;i&gt;doOperation()&amp;nbsp;&lt;/i&gt;sequence of events is as follows:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Publishes the endpoint that processes the service&amp;rsquo;s async reply (line 10).&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Creates a client that has WS-Addressing enabled (lines 13-14).&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Adds the &lt;i&gt;ReplyTo&lt;/i&gt;&amp;nbsp;element &amp;nbsp;to the request&amp;rsquo;s SOAP header (lines 17-18). The element contains the callback URL that the service will read in order to know to whom it should deliver its response and how it should deliver it.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Calls asynchronously the SEI method&amp;nbsp;&lt;i&gt;sayHiAsync()&lt;/i&gt;&amp;nbsp;(line 21).&amp;nbsp;If the consumer invokes the synchronous&amp;nbsp;method (i.e., &lt;i&gt;sayHi()&lt;/i&gt;) instead of the async one, the&amp;nbsp;consumer&amp;nbsp;would block indefinitely after sending out the request because it will wait for a reply that it will never receive.&lt;/li&gt;&lt;/ol&gt;The endpoint consuming the service&amp;rsquo;s reply is a plain Web Service:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=Callback.java&#34;&gt;&lt;/script&gt;The callback terminates the program as soon as it processes the reply.&lt;br /&gt;&lt;br /&gt;I re-run &lt;i&gt;wsdl2java&lt;/i&gt;&amp;nbsp;to generate another SEI but using the following arguments:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=generate-server.sh&#34;&gt;&lt;/script&gt;I use the SEI generated from the above command to implement the service:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=GreeterImpl.java&#34;&gt;&lt;/script&gt;Nothing special about &lt;i&gt;GreeterImpl.java&lt;/i&gt; except the &lt;i&gt;@Addressing&lt;/i&gt; annotation. This annotation is required for CXF to process the request&amp;rsquo;s WS-Addressing headers.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Main.java&lt;/i&gt; triggers the server and consumer into action:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=Main.java&#34;&gt;&lt;/script&gt;The complete application is on&amp;nbsp;&lt;a href=&#34;https://github.com/claudemamo/zmq-replyto-soap&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&amp;nbsp;The instructions for running the demo are almost identical to the ones of the previous post. First enter the following Maven command from the project&amp;rsquo;s root directory: &lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=build.sh&#34;&gt;&lt;/script&gt;Then run the demo using the &lt;i&gt;java&lt;/i&gt; command:&lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=run.sh&#34;&gt;&lt;/script&gt;You should then get the following output: &lt;br /&gt;&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/claudemamo/4577639.js?file=gistfile1.txt&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>